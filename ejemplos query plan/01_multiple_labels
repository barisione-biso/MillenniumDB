SELECT *
MATCH (?n :Label1 :Label2)

Al ir a los operadores:
    NodeLabel(Label1, ?n)
    NodeLabel(Label2, ?n)

3 planes posibles:

Merge (
    NodeLabel(Label1, ?n), (1)
    NodeLabel(Label2, ?n)  (2)
)
_________________________________________________

IndexNestedLoopJoin (
    NodeLabel(Label1, ?n), (1)
    NodeLabel(Label2, !n)  (2)
)
_________________________________________________

IndexNestedLoopJoin (
    NodeLabel(Label2, ?n), (1)
    NodeLabel(Label1, !n)  (2)
)

Costo Merge = ( Cost(1) + Cost(2) ) * (1 + Cost(RecordComparation))

Costo IndexNestedLoopJoin = Cost(1) + ( OutputSize(1) * Cost(2) )

Costo NodeLabel(Label, ?n) =   Cost(B+Tree::search)
                             + Cost(ReadPage) * (catalog.get_estimate(Label, graph) / max_tuples_per_page)
                             + Cost(B+Tree::next) * catalog.get_estimate(Label, graph)

Costo NodeLabel(Label, !n) = Cost(B+Tree::search)


1 10.000
2 3 4 5 6 7 8 ... 9.999